'\" t
.\"     srecord - The "srecord" program.
.\"     Copyright (C) 1998-2008 Peter Miller
.\"
.\"     This program is free software; you can redistribute it and/or modify
.\"     it under the terms of the GNU General Public License as published by
.\"     the Free Software Foundation; either version 3 of the License, or
.\"     (at your option) any later version.
.\"
.\"     This program is distributed in the hope that it will be useful,
.\"     but WITHOUT ANY WARRANTY; without even the implied warranty of
.\"     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\"     GNU General Public License for more details.
.\"
.\"     You should have received a copy of the GNU General Public License
.\"     along with this program. If not, see
.\"     <http://www.gnu.org/licenses/>.
.\"
.ds n) srec_input
.TH \*(n) 1 SRecord "Reference Manual"
.SH NAME
\*(n) \- input file specifications
.XX "srec_input(1)" "input file specifications"
.SH SYNOPSIS
\f[B]srec_*\fP \f[I]filename\fP [ \f[I]format\fP ]
.SH DESCRIPTION
This manual page describes the input file specifications for the
\f[I]srec_cat\fP(1), \f[I]srec_cmp\fP(1) and \f[I]srec_info\fP(1)
commands.
.PP
Input files may be qualified in a number of ways: you may specify their
format and you may specify filters to apply to them.
An input file specification looks like this:
.RS
\f[I]filename\fP [ \f[I]format\fP ][ \-ignore-checksums ]\
[ \f[I]filter\fP \&... ]
.RE
.PP
The
.I filename
The filename may be specified as a file name,
or the special name \(lq-\(rq which is understood to mean the standard input.
.SS Grouping with Parentheses
There are some cases where operator precedence of the filters can
be ambiguous.  Input specifications may also be enclosed by \fB(\fP
parentheses \fB)\fP to make grouping explicit.  Remember that the
presenthese must be separate words, \f[I]i.e.\fP surrounded by
spaces, and they will need to be quoted to get them past the shell's
interpretation of parentheses.
.SS File Formats
The
.I format
is specified by the argument \f[I]after\fP the file name.
The format defaults to Motorola S-Record if not specified.
The format specified are:
.TP 8n
\fB\-Absolute_Object_Module_Format\fP
This option says to use the Intel Absolute Object Module Format (AOMF) to read
the file.  (See \f[I]srec_aomf\fP(5) for a description of this file format.)
.TP 8n
\fB\-Ascii-Hex\fP
This option says to use the Ascii-Hex format to read the file.
See
.IR srec_ascii_hex (5)
for a description of this file format.
.TP 8n
\fB\-Atmel_Generic\fP
This option says to use the Atmel Generic format to read the file.
See
.IR srec_atmel_genetic (5)
for a description of this file format.
.TP 8n
\fB\-Binary\fP
This option says the file is a raw binary file, and should be read literally.
(This option may also be written \-Raw.)
See \f[I]srec_binary\fP(5) for more information.
.TP 8n
\fB\-B-Record\fP
This option says to use the Freescale MC68EZ328 Dragonball bootstrap
b-record format to read the file.
See \f[I]srec_brecord\fP(5) for a description of this file format.
.TP 8n
\fB\-COsmac\fP
This option says to use the RCA Cosmac Elf format to read the file.
See \f[I]srec_cosmac\fP(5) for a description of this file format.
.TP 8n
\fB\-Dec_Binary\fP
This option says to use the DEC Binary (XXDP) format to read the file.
See \f[I]srec_dec_binary\fP(5) for a description of this file format.
.TP 8n
\fB\-Elektor_Monitor52\fP
This option says to use the EMON52 format to read the file.
See \f[I]srec_emon52\fP(5) for a description of this file format.
.TP 8n
\fB\-Ff[I]rchild\fP
This option says to use the Fairchild Fairbug format to read the file.
See \f[I]srec_fairchild\fP(5) for a description of this file format.
.TP 8n
\fB\-Fast_Load\fP
This option says to use the LSI Logic Fast Load format to read the file.
See \f[I]srec_fastload\fP(5) for a description of this file format.
.TP 8n
\fB\-Formatted_Binary\fP
This option says to use the Formatted Binary format to read the file.
See \f[I]srec_formatted_binary\fP(5) for a description of this file format.
.TP 8n
\fB\-Four_Packed_Code\fP
This option says to use the FPC format to read the file.
See \f[I]srec_fpc\fP(5) for a description of this file format.
.TP 8n
\fB\-Guess\fP
This option may be used to ask \*(n) to guess the input format.
This is slower than specifying an explicit format,
as it may open and close the file a number of times.
.TP 8n
\fB\f[I]ntel\fP
This option says to use the Intel hex format to read the file.
See
.IR srec_intel (5)
for a description of this file format.
.TP 8n
\fB\-INtel_HeX_16\fP
This option says to use the Intel hex 16 (INHX16) format to read the file.
See
.IR srec_intel16 (5)
for a description of this file format.
.TP 8n
\fB\-MOS_Technologies\fP
This option says to use the Mos Technologies format to read the file.
See
.IR srec_mos_tech (5)
for a description of this file format.
.TP 8n
\fB\-Motorola\fP [ \f[I]width\fP ]
.RS
This option says to use the Motorola S-Record format to read the file.
(May also be written \-S-Record.)
See
.IR srec_motorola (5)
for a description of this file format.
.PP
The optional \f[I]width\fP argument describes the number of bytes which
form each address multiple.  For normal uses the default of one (1) byte
is appropriate.  Some systems with 16-bit or 32-bit targets mutilate the
addresses in the file; this option will correct for that.
Unlike most other parameters, this one cannot be guessed.
.RE
.TP 8n
\fB\-Needham_Hexadecimal\fP
This option says to use the Needham Electronics ASCII file format to
read the file.  See \f[I]srec_needham\fP(5) for a description of this
file format.
.TP 8n
\fB\-Ohio_Scientific\fP
This option says to use the Ohio Scientific format.
See \f[I]srec_os65v\fP(5) for a description of this file format.
.TP 8n
\fB\-SIGnetics\fP
This option says to use the Signetics format.
See \f[I]srec_spasm\fP(5) for a description of this file format.
.TP 8n
\fB\-SPAsm\fP
This option says to use the SPASM assembler output format (commonly used
by PIC programmers).
See \f[I]srec_spasm\fP(5) for a description of this file format.
.TP 8n
\fB\-SPAsm_LittleEndian\fP
This option says to use the SPASM assembler output format (commonly used
by PIC programmers).  But with the data the other way around.
.TP 8n
\fB\-STewie\fP
This option says to use the Stewie binary format to read the file.
See
.IR srec_stewie (5)
for a description of this file format.
.TP 8n
\fB\-Tektronix\fP
This option says to use the Tektronix hex format to read the file.
See
.IR srec_tektronix (5)
for a description of this file format.
.TP 8n
\fB\-Tektronix_Extended\fP
This option says to use the Tektronix extended hex format to read the file.
See
.IR srec_tektronix_extended (5)
for a description of this file format.
.TP 8n
\fB\-Texas_Instruments_Tagged\fP
This option says to use the Texas Instruments Tagged format to read the file.
See
.IR srec_ti_tagged (5)
for a description of this file format.
.TP 8n
\fB\-Texas_Instruments_Tagged_16\fP
This option says to use the Texas Instruments SDSMAC 320 format to read
the file.  See
.IR srec_ti_tagged_16 (5)
for a description of this file format.
.TP 8n
\fB\-Texas_Instruments_TeXT\fP
This option says to use the Texas Instruments TXT (MSP430) format to
read the file.  See \f[I]srec_ti_txt\fP(5) for a description of this
file format.
.TP 8n
\fB\-VMem\fP
This option says to use the Verilog VMEM format to read the file.
See \f[I]srec_vmem\fP(5) for a description of this file format.
.TP 8n
\fB\-WILson\fP
This option says to use the wilson format to read the file.
See
.IR srec_wilson (5)
for a description of this file format.
.SS Ignore Checksums
.so man/man1/o_ignore_checksums.so
.SS Generators
It is also possible to generate data, rather than read it from a file.
You may use a generator anywhere you could use a file.
An input generator specification looks like this:
.PP
.in +0.25i
\fB\-GENerate\fP \f[I]address-range\fP \fB\-\fP\f[I]data-source\fP
.in -0.25i
.PP
The \fB\-\fP\f[I]data-source\fP may be one of the following:
.TP 8n
\fB\-CONSTant\fP \f[I]number\fP
.RS
This generator manufactures data with the given byte value of the
the given address range.
For example, to fill memory addresses 100..199 with newlines (0x0A),
you could use a command like
.PP
.nf
.in +0.25i
.ft CW
srec_cat \-generate 100 200 \-constant 10 -o newlines.srec
.ft P
.in -0.25i
.fi
.PP
This can, of course, be combined with data from files.
.RE
.TP 8n
\fB\-REPeat_Data\fP \f[I]number\fP...
.RS
This generator manufactures data with the given byte values repeating
over the the given address range.
For example, to create a data region with 0xDE in the even bytes and 0xAD
in the odd bytes, use a generator like this:
.PP
.nf
.in +0.25i
.ft CW
srec_cat \-generate 0x1000 0x2000 \-repeat-data 0xDE 0xAD
.ft P
.in -0.25i
.fi
.PP
The repeat boundaries are aligned with the base of the address range,
modulo the number of bytes.
.RE
.TP 8n
\fB\-REPeat_String\fP \f[I]text\fP
.RS
This generator is almost identical to \-repeat-data except that the data
to be repeated is the text of the given string.
For example, to fill the holes in an EPROM image \f[I]eprom.srec\fP with the
text \(lqCopyright (C) 1812 Tchaikovsky\(rq, combine a generator and an
\-exclude filter, such as the command
.PP
.nf
.in +0.25i
.ft CW
srec_cat eprom.srec \e
    -generate 0 0x100000 \e
        -repeat-string 'Copyright (C) 1812 Tchaikovsky. ' \e
        -exclude -within eprom.srec \e
    -o eprom.filled.srec
.ft R
.in -0.25i
.fi
.PP
The thing to note is that we have two data sources: the \f[I]eprom.srec\fP
file, and generated data over an address range which covers first
megabyte of memory but excluding areas covered by the \f[I]eprom.srec\fP data.
.RE
.PP
Anything else will result in an error.
.SS Input Filters
You may specify zero or more \f[I]filters\fP to be applied.
Filters are applied in the order the user specifies.
.TP 8n
\fB\-Big_Endian_Checksum_BitNot\fP \f[I]address\fP [ \f[I]nbytes\fP [ \
\f[I]width\fP ]]
This filter may be used to insert the one's complement checksum of the
data into the data, most significant byte first.
The data is literally summed; if there are duplicate bytes, this will
produce an incorrect result, if there are holes, it will be as if they were
filled with zeros.
If the data already contains bytes at the checksum location,
you need to use an exclude filter, or this will generate errors.
You need to apply and crop or fill filters before this filter.
The value will be written with the most significant byte first.
The number of bytes of resulting checksum defaults to 4.
The width (the width in bytes of the values being summed) defaults to 1.
.TP 8n
\fB\-Big_Endian_Checksum_Negative\fP \f[I]address\fP [ \f[I]nbytes\fP [ \
\f[I]width\fP ]]
This filter may be used to insert the two's complement (negative)
checksum of the data into the data.  Otherwise similar to the above.
.TP 8n
\fB\-Big_Endian_Checksum_Positive\fP \f[I]address\fP [ \f[I]nbytes\fP [ \
\f[I]width\fP ]]
This filter may be used to insert the simple checksum of the data into
the data.  Otherwise similar to the above.
.TP 8n
\fB\-Little_Endian_Checksum_BitNot\fP \f[I]address\fP [ \f[I]nbytes\fP [ \
\f[I]width\fP ]]
This filter may be used to insert the one's complement (bitnot)
checksum of the data into the data, least significant byte first.
Otherwise similar to the above.
.TP 8n
\fB\-Little_Endian_Checksum_Negative\fP \f[I]address\fP [ \f[I]nbytes\fP [ \
\f[I]width\fP ]]
This filter may be used to insert the two's complement (negative)
checksum of the data into the data.  Otherwise similar to the above.
.TP 8n
\fB\-Little_Endian_Checksum_Negative\fP \f[I]address\fP [ \f[I]nbytes\fP [ \
\f[I]width\fP ]]
This filter may be used to insert the simple checksum of the data into
the data.  Otherwise similar to the above.
.TP 8n
\fB\-Byte_Swap\fP [ \f[I]width\fP ]
This filter may be used to swap pairs of odd and even bytes.
By specifying a width (in bytes) it is possible to reverse the order
of 4 and 8 bytes, the default is 2 bytes.  (Widths in excess of 8 are
assumed to be number of bits.)
It is not possible to swap non-power-of-two addresses.
To change the alignment, use the offset filter before and after.
.TP 8n
\fB\-Big_Endian_CRC16\fP \f[I]address\fP \
[ \-CCITT | \-XMODEM | \-BROKEN ]\
[ \-AUGment | \-No-AUGment ]
.RS
This filter may be used to insert an industry standard 16-bit CRC checksum
of the data into the data.  Two bytes, big-endian order, are inserted
at the address given.  Holes in the input data are ignored.  Bytes are
processed in ascending address order (\f[I]not\fP in the order they appear
in the input).
.PP
The following additional modifiers are understood:
.TP 8n
\fB\-CCITT
The CCITT calculation is performed.
The initial seed is 0xFFFF.
This is the default.
.TP 8n
\fB\-XMODEM\fP
The alternate XMODEM calculation is performed.
The initial seed is 0x0000.
.TP 8n
\fB\-BROKEN\fP
A common-but-broken calculation is performed.
The initial seed is 0x84CF.
.TP 8n
\fB\-AUGment
The CRC is augmented by sixteen zero bits at the end of the calculation.
do not use it.
This is the default.
.TP 8n
\fB\-No-AUGment
The CRC is not augmented at the end of the calculation.
This is less standard conforming, but some implementations do this.
.PP
\fBNote:\fP If you have holes in your data, you will get a different CRC
than if there were no holes.  This is important because the in-memory
EPROM image will not have holes.  You almost always want to use the
\fB\-fill\fP filter before any of the CRC filters.
You will receive a warning if the data presented for CRC has holes.
.PP
You should also be aware that the lower and upper bounds of your data
may not be the same as the lower and upper bounds of your EPROM.  This
is another reason to use the \fB\-fill\fP filter, because it will
establish the data across the full EPROM address range.
.PP
Note that there are a great many CRC16 implementations out there,
see http://www.joegeluso.com/software/articles/ccitt.htm for more
information.  If all else fails, SRecord is open source software:
read the SRecord source code.  The CRC16 source code (found in the
\f[CW]lib/crc16.cc\fP file of the distribution tarball) has a great many
explanatory comments.
.PP
Please try all six combinations of the above options before reporting a
bug in the CRC16 calculation.
.RE
.TP 8n
\fB\-Little_Endian_CRC16\fP \f[I]address\fP
As above, except little-endian order.
.TP 8n
\fB\-Big_Endian_CRC32\fP \f[I]address\fP
.RS
This filter may be used to insert an industry standard 32-bit CRC checksum
of the data into the data.  Four bytes, big-endian order, are inserted
at the address given.  Holes in the input data are ignored.  Bytes are
processed in ascending address order (\f[I]not\fP in the order they appear
in the input).
See also the note about holes, above.
.PP
The following additional modifiers are understood:
.TP 8n
\fB\-CCITT
The CCITT calculation is performed.
The initial seed is all one bits.
This is the default.
.TP 8n
\fB\-XMODEM\fP
An alternate XMODEM-style calculation is performed.
The initial seed is all zero bits.
.RE
.TP 8n
\fB\-Little_Endian_CRC32\fP \f[I]address\fP
As above, except little-endian order.
.TP 8n
\fB\-Crop\fP \f[I]address-range\fP
This filter may be used to isolate a section of data, and discard the
rest.
.TP 8n
\fB\-Exclude\fP \f[I]address-range\fP
This filter may be used to exclude a section of data, and keep the rest.
The is the logical complement of the \fB\-Crop\fP filter.
.TP 8n
\fB\-Fill\fP \f[I]value\fP \f[I]address-range\fP
This filter may be used to fill any gaps in the data with bytes equal
to \f[I]value\fP.  The fill will only occur in the address range given.
.TP 8n
\fB\-UnFill\fP \f[I]value\fP [ \f[I]min-run-length\fP ]
This filter may be used to create gaps in the data with bytes equal
to \f[I]value\fP.  You can think of it as reversing the effects of the
\fB\-Fill\fP filter.  The gaps will only be created if the are at least
\f[I]min-run-length\fP bytes in a row (defaults to 1).
.TP 8n
\fB\-Random_Fill\fP \f[I]address-range\fP
This filter may be used to fill any gaps in the data with random bytes.
The fill will only occur in the address range given.
.TP 8n
\fB\-AND\fP \f[I]value\fP
This filter may be used to bit-wise AND a \f[I]value\fP to every data byte.
This is useful if you need to clear bits.
Only existing data is altered, no holes are filled.
.TP 8n
\fB\-eXclusive-OR\fP \f[I]value\fP
This filter may be used to bit-wise XOR a \f[I]value\fP to every data byte.
This is useful if you need to invert bits.
Only existing data is altered, no holes are filled.
.TP 8n
\fB\-OR\fP \f[I]value\fP
This filter may be used to bit-wise OR a \f[I]value\fP to every data byte.
This is useful if you need to set bits.
Only existing data is altered, no holes are filled.
.TP 8n
\fB\-NOT\fP
This filter may be used to bit-wise NOT the value of every data byte.
This is useful if you need to invert the data.
Only existing data is altered, no holes are filled.
.TP 8n
\fB\-Big_Endian_Length\fP \f[I]address\fP [ \f[I]nbytes\fP ]
This filter may be used to insert the length of the data (high water
minus low water) into the data.  This includes the length itself.
If the data already contains bytes at the length location,
you need to use an exclude filter, or this will generate errors.
The value will be written with the most significant byte first.
The number of bytes defaults to 4.
.TP 8n
\fB\-Little_Endian_Length\fP \f[I]address\fP [ \f[I]nbytes\fP ]
As above, however
the value will be written with the least significant byte first.
.TP 8n
\fB\-Big_Endian_MAXimum\fP \f[I]address\fP [ \f[I]nbytes\fP ]
This filter may be used to insert the maximum address of the data (high water
 + 1) into the data.  This includes the maximum itself.
If the data already contains bytes at the given address,
you need to use an exclude filter, or this will generate errors.
The value will be written with the most significant byte first.
The number of bytes defaults to 4.
.TP 8n
\fB\-Little_Endian_MAXimum\fP \f[I]address\fP [ \f[I]nbytes\fP ]
As above, however
the value will be written with the least significant byte first.
.TP 8n
\fB\-Big_Endian_MINimum\fP \f[I]address\fP [ \f[I]nbytes\fP ]
This filter may be used to insert the minimum address of the data (low
water) into the data.  This includes the minimum itself.
If the data already contains bytes at the given address,
you need to use an exclude filter, or this will generate errors.
The value will be written with the most significant byte first.
The number of bytes defaults to 4.
.TP 8n
\fB\-Little_Endian_MINimum\fP \f[I]address\fP [ \f[I]nbytes\fP ]
As above, however
the value will be written with the least significant byte first.
.TP 8n
\fB\-OFfset\fP \f[I]nbytes\fP
This filter may be used to
offset the addresses by the given number of bytes.
No data is lost, the addresses will wrap around in 32 bits, if necessary.
You may use negative numbers for the offset,
if you wish to move data lower in memory.
.TP 8n
\fB\-SPlit\fP \f[I]multiple\fP [ \f[I]offset\fP [ \f[I]width\fP ] ]
This filter may be used to split the input into a subset of the data,
and compress the address range so as to leave no gaps.  This useful for
wide data buses and memory striping.  The \f[I]multiple\fP is the bytes
multiple to split over, the \f[I]offset\fP is the byte offset into this
range (defaults to 0), the \f[I]width\fP is the number of bytes to extract
(defaults to 1) within the multiple.  In order to leave no gaps, the
output addresses are (\f[I]width\fP / \f[I]multiple\fP) times the input
addresses.
.TP 8n
\fB\-Un_SPlit\fP \f[I]multiple\fP [ \f[I]offset\fP [ \f[I]width\fP ] ]
This filter may be used to reverse the effects of the split filter.
The arguments are identical.
Note that the address range is expanded (\f[I]multiple\fP / \f[I]width\fP)
times, leaving holes between the stripes.
.SS Address Ranges
There are three ways to specify an address range:
.TP 8n
\f[I]minimum\fP \f[I]maximum\fP
If you specify two number on the command line (decimal, octal and
hexadecimal are understood, using the C conventions) this is an explicit
address range.  The minimum is inclusive, the maximum is exclusive (one
more than the last address).  If the maximum is given as zero then the
range extends to the end of the address space.
.TP 8n
\fB\-Within\fP \f[I]input-specification\fP
.RS
This says to use the specified input file as a mask.  The range
includes all the places the specified input has data, and holes where
it has holes.  The input specification need not be just a file name,
it may be anything any other input specification can be.
.PP
See also the \fB\-over\fP option for a discusson on operator precedence.
.RE
.TP 8n
\fB\-OVER\fP \f[I]input-specification\fP
.RS
This says to use the specified input file as a mask.  The range
extends from the minimum to the maximum address used by the input, and
ignores any holes.  The input specification need not be just a file name,
it may be anything any other input specification can be.
.PP
You may need to enclose \f[I]input-specification\fP in parentheses
to make sure it can't misinterpret which arguments go with which input
specification.
This is particularly inportant when a filter
is to follow.  For example
.RS
\f[I]filename\fP -fill 0 -over \f[I]filename2\fP \-swap-bytes
.RE
groups as
.RS
\f[I]filename\fP -fill 0 -over '(' \f[I]filename2\fP \-swap-bytes ')'
.RE
when what you actually wanted was
.RS
\&'(' \f[I]filename\fP -fill 0 -over \f[I]filename2\fP ')' \-swap-bytes
.RE
The command line expression parsing tends to be \[lq]greedy\[rq] (or
right associative) rather than conservative (or left associative).
.RE
.TP 8n
\f[I]address-range\fP \fB\-RAnge-PADding\fP \f[I]number\fP
.RS
It is also possible to pad ranges to be whole aligned multiples of the
given number.  For example
.RS
\f[I]input-file\fP -fill 0xFF -within \f[I]input-file\fP -range-pad 512
.RE
will fill the \f[I]input-file\fP so that it consists of whole 512-byte
blocks, aligned on 512 byte boundaries.  Any large holes in the data
will also be multiples of 512 bytes, though they may have been shrunk as
blocks before and after are padded.
.PP
This operator has the same precedence as the explicit union operator.
.RE
.TP 8n
\f[I]address-range\fP \fB\-INTERsect\fP \f[I]address-range\fP
You can intersect two address ranges to produce a smaller address range.
The intersection operator has higher precedence than the implicit union
operator (evaluated left to right).
.TP 8n
\f[I]address-range\fP \fB\-Uf[I]on\fP \f[I]address-range\fP
You can union two address ranges to produce a larger address range.  The
union operator has lower precedence than the intersection operator
(evaluated left to right).
.TP 8n
\f[I]address-range\fP \fB\-DIFference\fP \f[I]address-range\fP
You can difference two address ranges to produce a smaller address
range.  The result is the left hand range with all of the right hand
range removed.  The difference operator has the same precedence as the
implicit union operator (evaluated left to right).
.TP 8n
\f[I]address-range\fP \f[I]address-range\fP
In addition, all of these methods may be used, and used more than
once, and the results will be combined (implicit union operator, same
precedence as explicit union operator).
.SS Calculated Values
Most of the places above where a number is expected, you may supply one
of the following:
.TP 8n
\f[B]\-\fP \f[I]value\fP
.RS
The value of this expression is the negative of the expression argument.
Note the \f[B]space\fP between the minus sign and its argument:
this space is mandatory.
.RS
.ft CW
srec_cat in.srec -offset - -minimum in.srec -o out.srec
.ft P
.RE
This example shows how to move data to the base of memory.
.RE
.TP 8n
\f[CW](\fP \f[I]value\fP \f[CW])\fP
You may use parentheses for grouping.
When using parentheses,
they must each be a separate command line argument,
they can't be within the text of the preceding or following option,
and you will need to quote them to get them past the shell,
such as \f[CW]'('\fP and \f[CW]')'\fP.
.TP 8n
\fB\-MINimum\fP \f[I]input-specification\fP
.RS
This inserts the minimum address of the specified input file.
The input specification need not be just a file name,
it may be anything any other input specification can be.
.PP
See also the \fB\-over\fP option for a discusson on operator precedence.
.RE
.TP 8n
\fB\-MAXimum\fP \f[I]input-specification\fP
.RS
This inserts the maximum address of the specified input file, plus one.
The input specification need not be just a file name,
it may be anything any other input specification can be.
.PP
See also the \fB\-over\fP option for a discusson on operator precedence.
.RE
.TP 8n
\fB\-Length\fP \f[I]input-specification\fP
.RS
This inserts the length of the address range in the specified input file,
ignoring any holes.  The input specification need not be just a file name,
it may be anything any other input specification can be.
.PP
See also the \fB\-over\fP option for a discusson on operator precedence.
.RE
.PP
For example, the \fB-OVER\fP \f[I]input-specification\fP
option can be thought of as short-hand for
\fB'(' \-min\fP \f[I]file\fP \fB\-max\fP \f[I]file\fP \fB')'\fP,
except that it is
much easier to type, and also more efficient.
.PP
In addition, calculated values may optionally be rounded in one of three ways:
.TP 8n
\f[I]value\fP \fB\-Round_Down\fP \f[I]number\fP
The \f[I]value\fP is rounded down to the the largest integer smaller than
or equal to a whole multiple of the \f[I]number\fP.
.TP 8n
\f[I]value\fP \fB\-Round_Nearest\fP \f[I]number\fP
The \f[I]value\fP is rounded to the the nearest whole multiple of
the \f[I]number\fP.
.TP 8n
\f[I]value\fP \fB\-Round_Up\fP \f[I]number\fP
The \f[I]value\fP is rounded up to the the smallest integer larger than
or equal to a whole multiple of the \f[I]number\fP.
.PP
When using parentheses,
they must each be a separate command line argument,
they can't be within the text of the preceding or following option,
and you will need to quote them to get them past the shell,
as \f[CW]'('\fP and \f[CW]')'\fP.
.so man/man1/z_copyright.so
.\" vim:ts=8:sw=4:et
